import json
import time
from pymetasploit3.msfrpc import MsfRpcClient

def get_all_exploits(client):
    """Retrieve all Exploit module paths"""
    try:
        # client.modules.exploits returns a list
        exploit_paths = client.modules.exploits
        print(f"[DEBUG] Retrieved {len(exploit_paths)} Exploit modules. Example: {exploit_paths[:3]}...")
        return exploit_paths
    except Exception as e:
        print(f"[!] Failed to get Exploit list: {str(e)}")
        return []

def get_exploit_payloads(client, exploit_path):
    """Get payloads for a single Exploit module (with retry mechanism)"""
    max_retries = 3
    for attempt in range(max_retries):
        try:
            exploit = client.modules.use('exploit', exploit_path)
            payloads = exploit.payloads
            if not payloads:
                print(f"[!] Warning: Payload list empty for {exploit_path}")
            return payloads
        except Exception as e:
            if attempt < max_retries - 1:
                print(f"[!] Retrying ({attempt+1}/{max_retries}) - {exploit_path}")
                time.sleep(1)
            else:
                print(f"[!] Permanent failure: {exploit_path} - {str(e)}")
                return []

def main():
    # Configure connection parameters
    password = "C4RpaE6X"  # Replace with your actual password
    client = MsfRpcClient(password, port=55552, ssl=False)
    
    # Allow time for Metasploit to load modules
    print("[*] Waiting for Metasploit to load all modules...")
    time.sleep(60)  # Wait 60 seconds
    
    # Retrieve all Exploit paths
    print("[*] Loading Exploit modules...")
    exploit_paths = get_all_exploits(client)
    total = len(exploit_paths)
    
    if total == 0:
        print("[!] Critical error: No Exploit modules found")
        print("Diagnostic suggestions:")
        print("1. Verify RPC service started with:")
        print("   msfrpcd -P your_password -a 127.0.0.1 -p 55553 -n")
        print("2. Wait at least 60 seconds for module loading")
        return
    
    print(f"[+] Successfully loaded {total} Exploit modules")
    
    # Initialize result container
    exploit_payload_list = []
    
    # Process in batches to reduce memory usage
    batch_size = 100
    for i in range(0, len(exploit_paths), batch_size):
        batch = exploit_paths[i:i + batch_size]
        print(f"[INFO] Processing batch {i//batch_size + 1}/{(len(exploit_paths) + batch_size - 1) // batch_size}")
        
        for idx, exploit_path in enumerate(batch, start=i + 1):
            # Get payloads for this exploit
            payloads = get_exploit_payloads(client, exploit_path)
            
            # Create result entry
            entry = {
                "id": idx,
                "exploit": exploit_path,
                "payloads": payloads
            }
            exploit_payload_list.append(entry)
            
            # Progress reporting (every 1% or min 10 items)
            if idx % max(1, total//100) == 0:
                progress = idx / total * 100
                print(f"[Progress] {progress:.1f}% | Processed {idx}/{total} - Current module: {exploit_path[:50]}...")

    # Save results
    output_file = "all_exploits_payloads.json"
    with open(output_file, "w", encoding='utf-8') as f:
        json.dump(exploit_payload_list, f, indent=4, ensure_ascii=False)
    
    print(f"\n[+] Operation complete! Results saved to {output_file}")
    print(f"Statistics:")
    print(f"- Total Exploit modules: {total}")
    print(f"- Average payloads per module: {sum(len(e['payloads']) for e in exploit_payload_list)/total:.1f}")

if __name__ == "__main__":
    # Record start timestamp
    start_time = time.strftime("%Y-%m-%d %H:%M:%S")
    print(f"[*] Script start time: {start_time}")
    
    try:
        main()
    except KeyboardInterrupt:
        print("\n[!] Execution interrupted by user")
    except Exception as e:
        print(f"[!] Unexpected error occurred: {str(e)}")
    
    # Calculate total duration
    end_time = time.time()
    elapsed_time = end_time - time.mktime(time.strptime(start_time, '%Y-%m-%d %H:%M:%S'))
    print(f"[*] Total execution time: {elapsed_time:.2f} seconds")
